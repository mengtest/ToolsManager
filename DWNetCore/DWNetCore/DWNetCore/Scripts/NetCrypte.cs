//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18063
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Security.Cryptography;
using System.IO;

public class NetCrypte
{
	//private Aes aes = null;
	private SymmetricAlgorithm cryto = null;
	private byte[] iv;
	private byte[] key;
	public bool isCrypte = false;
	public int pkgLen = 2;
	public int blockSize = 128;

	public NetCrypte ()
	{
		//if (aes == null)
		//	return;
		//aes = AesManaged.Create ();
		//aes = AesCryptoServiceProvider.Create ();

		//InitDes ();
		InitAes ();
		setIV ("d62f5b5677d299957ab8aa8fe7dd95e7");
		setKey("d62f5b5677d299957ab8aa8fe7dd95e7");
	}

	public void InitAes()
	{
		cryto = new RijndaelManaged ();
		cryto.Padding = PaddingMode.Zeros;
		cryto.BlockSize = 128;
		cryto.Mode = CipherMode.CBC;
		blockSize = 128;
	}

	public void InitDes()
	{
		cryto = new DESCryptoServiceProvider ();
		cryto.Padding = PaddingMode.Zeros;
		cryto.BlockSize = 64;
		cryto.Mode = CipherMode.CBC;
		blockSize = 64;
	}

	public static byte[] ParseHexString(string hexString)
	{
		byte[] outData = new byte[(int)Math.Ceiling(((double)hexString.Length) / 2)];
		for(int i=0; i<outData.Length; ++i)
		{
			string s = hexString.Substring(i*2, 2);
			outData[i] = byte.Parse(s, System.Globalization.NumberStyles.AllowHexSpecifier);
		}
		return outData;
	}

	public void setIV(string hexString) 
	{
		if (cryto == null)
			return;
		iv = ParseHexString (hexString.Substring(0, blockSize/4));
		cryto.IV = iv;
	}
	public void setKey(string hexString)
	{
		if (cryto == null)
			return;
        if (string.IsNullOrEmpty(hexString))
            hexString = hexString;
        key = ParseHexString (hexString.Substring(0, blockSize/4));
		cryto.Key = key;
	}

	public byte[] Encrypte(byte[] inData)
	{
		if (!isCrypte)
			return inData;

		System.Security.Cryptography.ICryptoTransform trs = cryto.CreateEncryptor ();
		byte[] eData = trs.TransformFinalBlock (inData, 0, inData.Length);
		byte[] outData = new byte[eData.Length + pkgLen];

		switch (pkgLen) {
		case 2:
			BitConverter.GetBytes (System.Net.IPAddress.HostToNetworkOrder ((short)inData.Length)).CopyTo (outData, 0);
			break;
		case 4:
			BitConverter.GetBytes(System.Net.IPAddress.HostToNetworkOrder((int)inData.Length)).CopyTo (outData, 0);
			break;
		}
		eData.CopyTo (outData, pkgLen);
		return outData;
	}

	public byte[] Decrypte (byte[] inData, int offset = 0, int length = 0)
    {
        UInt32 len = 0;
        int deLen = length == 0 ? inData.Length : length;
        if (!isCrypte)
        {
            byte[] outData = new byte[deLen];
            Array.Copy(inData,pkgLen, outData, 0, deLen);
            return outData;
        }

        switch (pkgLen) {
		case 2:
			if (inData.Length < 2) {
				UnityEngine.Debug.LogError("indata len less then 2." + inData.Length);
			}
			len = (UInt32)((UInt16)System.Net.IPAddress.NetworkToHostOrder ((short)BitConverter.ToUInt16 (inData, offset)));
			break;
		case 4:
			len = (UInt32)System.Net.IPAddress.NetworkToHostOrder ((int)BitConverter.ToUInt32 (inData, offset));
			break;
		}
		System.Security.Cryptography.ICryptoTransform trs = cryto.CreateDecryptor (key, iv);
		byte[] ddate = trs.TransformFinalBlock (inData, pkgLen, deLen - pkgLen);
		return ddate;
	}

    public byte[] Decrypte(byte[] inData, out int len, int offset = 0, int length = 0)
    {
        len = 0;
        int deLen = length == 0 ? inData.Length : length;

        if (!isCrypte)
        {
            byte[] outData = new byte[len];
            Array.Copy(inData, offset + pkgLen, outData, 0, deLen - pkgLen);
            return outData;
        }

        switch (pkgLen)
        {
            case 2:
                if (inData.Length < 2)
                {
                    UnityEngine.Debug.LogError("indata len less then 2." + inData.Length);
                }
                len = ((UInt16)System.Net.IPAddress.NetworkToHostOrder((short)BitConverter.ToUInt16(inData, offset)));
                break;
            case 4:
                len = System.Net.IPAddress.NetworkToHostOrder((int)BitConverter.ToUInt32(inData, offset));
                break;
        }
        System.Security.Cryptography.ICryptoTransform trs = cryto.CreateDecryptor(key, iv);
        byte[] ddate = trs.TransformFinalBlock(inData, offset + pkgLen, deLen - pkgLen);
        return ddate;
    }


    public System.Security.Cryptography.ICryptoTransform GetCryptoTransform()
    {
        return cryto.CreateDecryptor(key, iv);
    }
}


