//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18063
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;


public class TransferStateInput : object
{
}

public delegate bool TransferStateBaseTransfer<T>(T curState, TransferStateInput input, T dstState);
public delegate void StateTransfer<T>(T curState, T dstState);

class TransferStateEntry<T>
{
    public TransferStateInput input;
    public T dstState;
    public TransferStateBaseTransfer<T> transfer;
}

public class TransferState<T>
    where T : struct, System.IConvertible, System.IComparable
{
    Dictionary<T, ArrayList> m_map;
    ArrayList m_allList;
    public T m_curState;
    public TransferStateBaseTransfer<T> m_transfer;

    private List<TransferStateInput> m_delayInputs = new List<TransferStateInput>();
    private bool m_inTransfer = false;


    public TransferState(T initState, IEqualityComparer<T> iquipaty = null)
    {
        m_map = new Dictionary<T, ArrayList>(iquipaty);
        m_allList = new ArrayList();
        m_curState = initState;
    }

    public void addTransfer(T curState, TransferStateInput input, T dstState, TransferStateBaseTransfer<T> transfer)
    {
        var entry = new TransferStateEntry<T>();
        entry.dstState = dstState;
        entry.input = input;
        entry.transfer = transfer;
        ArrayList list;
        if (m_map.ContainsKey(curState))
        {
            list = m_map[curState];
        }
        else
        {
            list = new ArrayList();
            m_map[curState] = list;
        }
        list.Add(entry);
    }

    public void addTransferAll(TransferStateInput input, T dstState, TransferStateBaseTransfer<T> transfer)
    {
        var entry = new TransferStateEntry<T>();
        entry.dstState = dstState;
        entry.input = input;
        entry.transfer = transfer;
        m_allList.Add(entry);
    }

    bool transfer(object e, TransferStateInput input)
    {
        var entry = e as TransferStateEntry<T>;
        bool tr = false;
        if (entry.input == null || entry.input.Equals(input))
        {
            if (entry.transfer != null)
            {
                tr = entry.transfer(m_curState, input, entry.dstState);
            }
            else
            {
                tr = true;
            }
            if (tr)
            {
                T preState = m_curState;
                m_curState = entry.dstState;
                if (m_transfer != null)
                {
                    m_transfer(preState,input ,entry.dstState);
                }
            }
        }
        return tr;
    }

    public void InputData(TransferStateInput input)
    {
        if (m_inTransfer)
        {
            m_delayInputs.Add(input);
            return;
        }
        m_inTransfer = true;
        try
        {
            //TransferStateEntry<T> entry = null;
            bool tr = false;
            ArrayList list = null;
            if (m_map.TryGetValue(m_curState, out list))
            {
                for (int i = 0; i < list.Count; ++i)
                {
                    tr = transfer(list[i], input);
                    if (tr)
                    {
                        break;
                    }
                }
            }

            if (!tr)
            {
                for (int i = 0; i < m_allList.Count; ++i)
                {
                    tr = transfer(m_allList[i], input);
                    if (tr)
                    {
                        break;
                    }
                }
            }
        }
        finally
        {
            m_inTransfer = false;
            if (m_delayInputs.Count > 0)
            {
                var sinput = m_delayInputs[0];
                m_delayInputs.RemoveAt(0);
                InputData(sinput);
            }
        }
    }

    public void clearDelayInput()
    {
        m_delayInputs.Clear();
    }

    public static bool operator ==(TransferState<T> r, TransferState<T> l)
    {
        if ((r as object) == null || (l as object) == null)
        {
            return (l as object) == (l as object);
        }
        return r.m_curState.Equals(l.m_curState);
    }
    public static bool operator ==(TransferState<T> r, T l)
    {
        if ((r as object) == null)
        {
            return false;
        }
        return r.m_curState.Equals(l);
    }
    public static bool operator !=(TransferState<T> r, TransferState<T> l)
    {
        if ((r as object) == null || (l as object) == null)
        {
            return (r as object) != (l as object);
        }
        return !r.m_curState.Equals(l.m_curState);
    }
    public static bool operator !=(TransferState<T> r, T l)
    {
        return !r.m_curState.Equals(l);
    }
    public override bool Equals(object o)
    {
        if (!(o is TransferState<T>))
        {
            return false;
        }
        TransferState<T> to = (TransferState<T>)o;
        return m_curState.Equals(to.m_curState);
    }
    public override int GetHashCode()
    {
        return this.m_curState.GetHashCode();

    }
}
